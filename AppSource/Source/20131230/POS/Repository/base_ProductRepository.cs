//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Data.Objects;
using System.Linq;
using System.Linq.Expressions;
using CPC.POS.Database;

namespace CPC.POS.Repository
{
    /// <summary>
    /// Repository for table base_Product 
    /// </summary>
    public partial class base_ProductRepository
    {
        #region Auto Generate Code

        #region Constructors

        // Default constructor
        public base_ProductRepository()
        {
        }

        #endregion

        #region Basic C.R.U.D. Operations

        /// <summary>
        /// Add new base_Product.
        /// </summary>
        /// <param name="base_Product">base_Product to add.</param>
        /// <returns>base_Product have been added.</returns>
        public base_Product Add(base_Product base_Product)
        {
            UnitOfWork.Add<base_Product>(base_Product);
            return base_Product;
        }

        /// <summary>
        /// Adds a sequence of new base_Product.
        /// </summary>
        /// <param name="base_Product">Sequence of new base_Product to add.</param>
        /// <returns>Sequence of new base_Product have been added.</returns>
        public IEnumerable<base_Product> Add(IEnumerable<base_Product> base_Product)
        {
            UnitOfWork.Add<base_Product>(base_Product);
            return base_Product;
        }

        /// <summary>
        /// Delete a existed base_Product.
        /// </summary>
        /// <param name="base_Product">base_Product to delete.</param>
        public void Delete(base_Product base_Product)
        {
            Refresh(base_Product);
            if (base_Product.EntityState != System.Data.EntityState.Detached)
                UnitOfWork.Delete<base_Product>(base_Product);
        }

        /// <summary>
        /// Delete a sequence of existed base_Product.
        /// </summary>
        /// <param name="base_Product">Sequence of existed base_Product to delete.</param>
        public void Delete(IEnumerable<base_Product> base_Product)
        {
            int total = base_Product.Count();
            for (int i = total - 1; i >= 0; i--)
                Delete(base_Product.ElementAt(i));
        }

        /// <summary>
        /// Returns the first base_Product of a sequence that satisfies a specified condition or 
        /// a default value if no such base_Product is found.
        /// </summary>
        /// <param name="expression">A function to test each base_Product for a condition.</param>
        /// <returns>    
        /// Null if source is empty or if no base_Product passes the test specified by expression; 
        /// otherwise, the first base_Product in source that passes the test specified by expression.
        /// </returns>
        public base_Product Get(Expression<Func<base_Product, bool>> expression)
        {
            return UnitOfWork.Get<base_Product>(expression);
        }

        /// <summary>
        /// Get all base_Product.
        /// </summary>
        /// <returns>The new IList&lt;base_Product&gt; instance.</returns>
        public IList<base_Product> GetAll()
        {
            return UnitOfWork.GetAll<base_Product>();
        }

        /// <summary>
        /// Get all base_Product that satisfies a specified condition.
        /// </summary>
        /// <param name="expression">A function to test each base_Product for a condition.</param>
        /// <returns>The new IList&lt;base_Product&gt; instance.</returns>
        public IList<base_Product> GetAll(Expression<Func<base_Product, bool>> expression)
        {
            return UnitOfWork.GetAll<base_Product>(expression);
        }

        /// <summary>
        /// Get all base_Product.
        /// </summary>
        /// <returns>The new IEnumerable&lt;base_Product&gt; instance.</returns>
        public IEnumerable<base_Product> GetIEnumerable()
        {
            return UnitOfWork.GetIEnumerable<base_Product>();
        }

        /// <summary>
        /// Get all base_Product that satisfies a specified condition.
        /// </summary>
        /// <param name="expression">A function to test each base_Product for a condition.</param>
        /// <returns>The new IEnumerable&lt;base_Product&gt; instance.</returns>
        public IEnumerable<base_Product> GetIEnumerable(Expression<Func<base_Product, bool>> expression)
        {
            return UnitOfWork.GetIEnumerable<base_Product>(expression);
        }

        /// <summary>
        /// Get all base_Product.
        /// </summary>
        /// <returns>The new IQueryable&lt;base_Product&gt; instance.</returns>
        public IQueryable<base_Product> GetIQueryable()
        {
            return UnitOfWork.GetIQueryable<base_Product>();
        }

        /// <summary>
        /// Get all base_Product that satisfies a specified condition.
        /// </summary>
        /// <param name="expression">A function to test each base_Product for a condition.</param>
        /// <returns>The new IQueryable&lt;base_Product&gt; instance.</returns>
        public IQueryable<base_Product> GetIQueryable(Expression<Func<base_Product, bool>> expression)
        {
            return UnitOfWork.GetIQueryable<base_Product>(expression);
        }

        /// <summary>
        /// Take a few base_Product in a sequence was sorted on server.
        /// </summary>
        /// <param name="ignoreCount">Number of base_Product will ignore.</param>
        /// <param name="takeCount">Number of base_Product will take.</param>
        /// <param name="keys">The key columns by which to order the results.</param>
        /// <returns>The new IList&lt;base_Product&gt; instance.</returns>
        public IList<base_Product> GetRange(int ignoreCount, int takeCount, string keys)
        {
            return UnitOfWork.GetRange<base_Product>(ignoreCount, takeCount, keys);
        }

        /// <summary>
        /// Take a few base_Product in a sequence was sorted on server.
        /// </summary>
        /// <param name="ignoreCount">Number of base_Product will ignore.</param>
        /// <param name="takeCount">Number of base_Product will take.</param>
        /// <param name="keys">The key columns by which to order the results.</param>
        /// <param name="expression">A function to test each base_Product for a condition.</param>
        /// <returns>The new IList&lt;base_Product&gt; instance.</returns>
        public IList<base_Product> GetRange(int ignoreCount, int takeCount, string keys, Expression<Func<base_Product, bool>> expression)
        {
            return UnitOfWork.GetRange<base_Product>(ignoreCount, takeCount, keys, expression);
        }

        /// <summary>
        /// Take a few base_Product in sequence was sorted by descending on server.
        /// </summary>
        /// <typeparam name="TKey">Type of base_Product to sort</typeparam>
        /// <param name="ignoreCount">Number of base_Product will ignore.</param>
        /// <param name="takeCount">Number of base_Product will take.</param>
        /// <param name="keySelector">The key columns by which to order the results.</param>
        /// <returns>The new IList&lt;base_Product&gt; instance.</returns>
        public IList<base_Product> GetRangeDescending<TKey>(int ignoreCount, int takeCount, Expression<Func<base_Product, TKey>> keySelector)
        {
            return UnitOfWork.GetRangeDescending(ignoreCount, takeCount, keySelector);
        }

        /// <summary>
        /// Take a few base_Product in sequence was sorted by descending on server.
        /// </summary>
        /// <typeparam name="TKey">Type of base_Product to sort</typeparam>
        /// <param name="ignoreCount">Number of base_Product will ignore.</param>
        /// <param name="takeCount">Number of base_Product will take.</param>
        /// <param name="keySelector">The key columns by which to order the results.</param>
        /// <param name="expression">A function to test each object for a condition.</param>
        /// <returns>The new IList&lt;base_Product&gt; instance.</returns>
        public IList<base_Product> GetRangeDescending<TKey>(int ignoreCount, int takeCount, Expression<Func<base_Product, TKey>> keySelector, Expression<Func<base_Product, bool>> expression)
        {
            return UnitOfWork.GetRangeDescending(ignoreCount, takeCount, keySelector, expression);
        }

        /// <summary>
        /// Updates an base_Product in the object context with data from the data source.
        /// </summary>
        /// <param name="base_Product">The base_Product to be refreshed.</param>
        public base_Product Refresh(base_Product base_Product)
        {
            UnitOfWork.Refresh<base_Product>(base_Product);
            if (base_Product.EntityState != System.Data.EntityState.Detached)
                return base_Product;
            return null;
        }

        /// <summary>
        /// Updates a sequence of base_Product in the object context with data from the data source.
        /// </summary>
        /// <typeparam name="base_Product">Type of object in a sequence to refresh.</typeparam>
        /// <param name="base_Product">Object collection to be refreshed.</param>
        public void Refresh(IEnumerable<base_Product> base_Product)
        {
            UnitOfWork.Refresh<base_Product>(base_Product);
        }

        /// <summary>
        /// Updates a sequence of base_Product in the object context with data from the data source.
        /// </summary>
        public void Refresh()
        {
            UnitOfWork.Refresh<base_Product>();
        }

        /// <summary>
        /// Persists all updates to the data source and resets change tracking in the object context.
        /// </summary>
        public void Commit()
        {
            UnitOfWork.Commit();
        }

        /// <summary>
        /// Persists all updates to the data source with the specified System.Data.Objects.SaveOptions.
        /// </summary>
        /// <param name="options">A System.Data.Objects.SaveOptions value that determines the behavior of the operation.</param>
        public void Commit(SaveOptions options)
        {
            UnitOfWork.Commit(options);
        }

        /// <summary>
        /// Starts a database transaction.
        /// </summary>
        public void BeginTransaction()
        {
            UnitOfWork.BeginTransaction();
        }

        /// <summary>
        /// Commits the database transaction.
        /// </summary>
        public void CommitTransaction()
        {
            UnitOfWork.CommitTransaction();
        }

        /// <summary>
        /// Rolls back a transaction from a pending state.
        /// </summary>
        public void RollbackTransaction()
        {
            UnitOfWork.RollbackTransaction();
        }

        #endregion

        #endregion

        #region Custom Code

        #region Private Methods

        /// <summary>
        /// Get product by resource
        /// </summary>
        /// <param name="resource"></param>
        /// <returns></returns>
        private base_Product Get(string resource)
        {
            // Convert product resource to Guid
            Guid productGuid = new Guid();
            Guid.TryParse(resource, out productGuid);

            // Get product to update quantity
            return this.Get(x => x.Resource.Equals(productGuid));
        }

        /// <summary>
        /// Update new quantity to OnHandStore
        /// </summary>
        /// <param name="product"></param>
        /// <param name="storeCode"></param>
        /// <param name="quantity"></param>
        /// <param name="isDecreased"></param>
        /// <returns></returns>
        private decimal UpdateOnHandStore(base_Product product, int storeCode, decimal quantity, bool isDecreased = false)
        {
            decimal onHandStore = 0;

            decimal newQuantity = quantity;
            if (isDecreased)
                newQuantity *= -1;

            if (product != null)
            {
                switch (storeCode)
                {
                    case 0:
                        product.OnHandStore1 += newQuantity;
                        onHandStore = product.OnHandStore1;
                        break;
                    case 1:
                        product.OnHandStore2 += newQuantity;
                        onHandStore = product.OnHandStore2;
                        break;
                    case 2:
                        product.OnHandStore3 += newQuantity;
                        onHandStore = product.OnHandStore3;
                        break;
                    case 3:
                        product.OnHandStore4 += newQuantity;
                        onHandStore = product.OnHandStore4;
                        break;
                    case 4:
                        product.OnHandStore5 += newQuantity;
                        onHandStore = product.OnHandStore5;
                        break;
                    case 5:
                        product.OnHandStore6 += newQuantity;
                        onHandStore = product.OnHandStore6;
                        break;
                    case 6:
                        product.OnHandStore7 += newQuantity;
                        onHandStore = product.OnHandStore7;
                        break;
                    case 7:
                        product.OnHandStore8 += newQuantity;
                        onHandStore = product.OnHandStore8;
                        break;
                    case 8:
                        product.OnHandStore9 += newQuantity;
                        onHandStore = product.OnHandStore9;
                        break;
                    case 9:
                        product.OnHandStore10 += newQuantity;
                        onHandStore = product.OnHandStore10;
                        break;
                    default:
                        break;
                }

                // Update total quantity
                product.QuantityOnHand += newQuantity;

                // Update quantity available in product
                product.QuantityAvailable = product.QuantityOnHand - product.QuantityOnCustomer;
            }

            // Get product store by store number
            base_ProductStore productStore = product.base_ProductStore.SingleOrDefault(x => x.StoreCode.Equals(storeCode));

            if (productStore != null)
            {
                // Update product store quantity
                productStore.QuantityOnHand += newQuantity;

                // Update quantity available
                productStore.QuantityAvailable = productStore.QuantityOnHand - productStore.QuantityOnCustomer;

                // Update quantity on hand for product UOM
                if (productStore.base_ProductUOM != null)
                    foreach (base_ProductUOM productUOMItem in productStore.base_ProductUOM)
                    {
                        if (productUOMItem.BaseUnitNumber != 0)
                            productUOMItem.QuantityOnHand = Math.Round(productStore.QuantityOnHand / productUOMItem.BaseUnitNumber, 2);
                    }
            }
            else
            {
                productStore = NewProductStore(product, storeCode);
                productStore.QuantityOnHand = onHandStore;
                productStore.QuantityAvailable = onHandStore;
            }

            return onHandStore;
        }

        /// <summary>
        /// Save adjustment when cost or quantity changed
        /// </summary>
        /// <param name="productModel"></param>
        /// <param name="productStoreModel"></param>
        private void SaveAdjustment(base_Product product, decimal deltaQuantity, int storeCode, DateTime loggedTime)
        {
            // Get product store by store code
            base_ProductStore productStore = product.base_ProductStore.SingleOrDefault(x => x.StoreCode.Equals(storeCode));

            // Create new product store
            if (productStore == null)
                productStore = new base_ProductStore
                {
                    StoreCode = storeCode
                };

            // Add new product store to database
            product.base_ProductStore.Add(productStore);

            // Get new and old quantity
            decimal newQuantity = productStore.QuantityOnHand + deltaQuantity;
            decimal oldQuantity = productStore.QuantityOnHand;

            // Get new and old cost
            decimal newCost = product.AverageUnitCost;
            decimal oldCost = product.AverageUnitCost;

            // Save quantity adjustment
            // Create new quantity adjustment item
            base_QuantityAdjustment quantityAdjustment = new base_QuantityAdjustment();
            quantityAdjustment.ProductId = product.Id;
            quantityAdjustment.ProductResource = product.Resource.ToString();
            quantityAdjustment.NewQty = newQuantity;
            quantityAdjustment.OldQty = oldQuantity;
            quantityAdjustment.AdjustmentQtyDiff = newQuantity - oldQuantity;
            quantityAdjustment.CostDifference = newCost * quantityAdjustment.AdjustmentQtyDiff;
            quantityAdjustment.LoggedTime = loggedTime;
            quantityAdjustment.Reason = (short)AdjustmentReason.TransferedStock;
            quantityAdjustment.Status = (short)AdjustmentStatus.Normal;
            quantityAdjustment.UserCreated = Define.USER.LoginName;
            quantityAdjustment.IsReversed = false;
            quantityAdjustment.StoreCode = storeCode;

            // Add new quantity adjustment item to database
            UnitOfWork.Add(quantityAdjustment);

            // Save cost adjustment
            // Create new cost adjustment item
            base_CostAdjustment costAdjustment = new base_CostAdjustment();
            costAdjustment.ProductId = product.Id;
            costAdjustment.ProductResource = product.Resource.ToString();
            costAdjustment.AdjustmentNewCost = newCost;
            costAdjustment.AdjustmentOldCost = oldCost;
            costAdjustment.AdjustCostDifference = newCost - oldCost;
            costAdjustment.NewCost = newCost * newQuantity;
            costAdjustment.OldCost = oldCost * newQuantity;
            costAdjustment.CostDifference = costAdjustment.NewCost - costAdjustment.OldCost;
            costAdjustment.LoggedTime = loggedTime;
            costAdjustment.Reason = (short)AdjustmentReason.TransferedStock;
            costAdjustment.Status = (short)AdjustmentStatus.Normal;
            costAdjustment.UserCreated = Define.USER.LoginName;
            costAdjustment.IsReversed = false;
            costAdjustment.StoreCode = storeCode;

            // Add new cost adjustment item to database
            UnitOfWork.Add(costAdjustment);
        }

        /// <summary>
        /// Create new product store
        /// </summary>
        /// <param name="productResource"></param>
        /// <param name="storeCode"></param>
        /// <returns></returns>
        private base_ProductStore NewProductStore(base_Product product, int storeCode)
        {
            base_ProductStore productStore = null;

            try
            {
                productStore = new base_ProductStore();
                productStore.Resource = Guid.NewGuid().ToString();
                productStore.ProductId = product.Id;
                productStore.ProductResource = product.Resource.ToString();
                productStore.StoreCode = storeCode;

                // Add new product store to database
                product.base_ProductStore.Add(productStore);
            }
            catch (Exception ex)
            {
                Xceed.Wpf.Toolkit.MessageBox.Show(ex.ToString(), "POS");
            }

            return productStore;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Update on hand quantity
        /// </summary>
        /// <param name="productResource">Resource of product that update quantity</param>
        /// <param name="storeNumber">Store number</param>
        /// <param name="quantity">Quantity</param>
        /// <param name="isDecreased">Quantity increase or decrease. Default is increase</param>
        /// <returns>The new on hand quantity</returns>
        public decimal UpdateOnHandQuantity(string productResource, int storeNumber, decimal quantity, bool isDecreased = false, decimal baseUnitNumber = 1)
        {
            decimal onHandStore = 0;

            // Get product
            base_Product product = Get(productResource);

            onHandStore = UpdateOnHandStore(product, storeNumber, quantity * baseUnitNumber, isDecreased);

            // Accept changes
            this.Commit();

            return onHandStore;
        }

        /// <summary>
        /// Transfer product from source to target store
        /// </summary>
        /// <param name="productResources">Product resource list</param>
        /// <param name="sourceStoreNumber">Source store number</param>
        /// <param name="targetStoreNumber">Target store number</param>
        /// <param name="quantity">Quantity</param>
        /// <param name="isReversed">Default is false</param>
        public void TransferStock(string productResource, int sourceStoreNumber, int targetStoreNumber,
            decimal quantity, bool isReversed = false, decimal baseUnitNumber = 1)
        {
            // Get logged time
            DateTime loggedTime = DateTimeExt.Now;

            // Get delta quantity
            decimal deltaQuantity = quantity * baseUnitNumber;

            // Get product
            base_Product product = Get(productResource);

            // Save adjustment when change quantity in source store
            SaveAdjustment(product, -1 * deltaQuantity, sourceStoreNumber, loggedTime);

            // Save adjustment when change quantity in target store
            SaveAdjustment(product, deltaQuantity, targetStoreNumber, loggedTime);

            // Decrease quantity at source store
            UpdateOnHandStore(product, sourceStoreNumber, deltaQuantity, !isReversed);

            // Increase quantity at target store
            UpdateOnHandStore(product, targetStoreNumber, deltaQuantity, isReversed);

            // Accept changes
            this.Commit();
        }

        /// <summary>
        /// Update quantity on order (PO)
        /// </summary>
        public void UpdateQuantityOnOrder(string productResource, int storeCode, decimal quantity)
        {
            // Get product
            base_Product product = Get(productResource);

            if (product != null)
            {
                // Update quantity on order in product
                product.QuantityOnOrder += quantity;

                // Get product store
                base_ProductStore productStore = product.base_ProductStore.SingleOrDefault(x => x.StoreCode.Equals(storeCode));

                // Create new product store
                if (productStore == null)
                {
                    productStore = NewProductStore(product, storeCode);
                }

                // Update quantity on order in product store
                productStore.QuantityOnOrder += quantity;
            }
        }

        /// <summary>
        /// Update quantity on customer (SO)
        /// </summary>
        public void UpdateQuantityOnCustomer(string productResource, int storeCode, decimal quantity)
        {
            // Get product
            base_Product product = Get(productResource);

            if (product != null)
            {
                Refresh(product);

                // Update quantity on order in product
                product.QuantityOnCustomer += quantity;

                // Update quantity available in product
                product.QuantityAvailable = product.QuantityOnHand - product.QuantityOnCustomer;

                // Get product store
                base_ProductStore productStore = product.base_ProductStore.SingleOrDefault(x => x.StoreCode.Equals(storeCode));

                // Create new product store
                if (productStore == null)
                {
                    productStore = NewProductStore(product, storeCode);
                }
                else
                {
                    UnitOfWork.Refresh<base_ProductStore>(productStore);
                }

                // Update quantity on order in product store
                productStore.QuantityOnCustomer += quantity;

                // Update quantity available in product store
                productStore.QuantityAvailable = productStore.QuantityOnHand - productStore.QuantityOnCustomer;

            }
        }

        /// <summary>
        /// Update OrderCost and AverageUnitCost
        /// </summary>
        /// <param name="productResource">Product Resource</param>
        /// <param name="storeCode">Store code</param>
        /// <param name="price">Max price of this product in PO</param>
        /// <param name="totalAmount">Sum of (Amount = Price * Quantity)</param>
        /// <param name="totalReceived">Sum of quantity received</param>
        public void UpdateCost(string productResource, int storeCode, decimal price, decimal totalAmount, decimal totalReceived)
        {
            // Get product
            base_Product product = Get(productResource);

            // Get product store
            base_ProductStore productStore = product.base_ProductStore.SingleOrDefault(x => x.StoreCode.Equals(storeCode));

            if (product != null && productStore != null)
            {
                // Update order cost by max price in PO
                product.OrderCost = price;

                decimal totalQuantity = productStore.QuantityOnHand + totalReceived;

                // Update average unit cost
                if (totalQuantity > 0)
                {
                    // AUC = (OnHand * Current AUC + QtyReceived * Price) / OnHand + QtyReceived
                    product.AverageUnitCost = Math.Round((productStore.QuantityOnHand * product.AverageUnitCost + totalAmount) / totalQuantity, 2);

                    // Calculator margin, markup
                    if (product.RegularPrice != 0)
                        product.MarginPercent = Math.Round(100 * (1 - product.AverageUnitCost / product.RegularPrice), 2);
                    if (product.AverageUnitCost != 0)
                        product.MarkupPercent = Math.Round(100 * (product.RegularPrice / product.AverageUnitCost - 1), 2);
                }
            }
        }

        /// <summary>
        /// Update product store to summary
        /// </summary>
        /// <param name="productResource">Product resource</param>
        /// <param name="storeCode">Storec code</param>
        /// <param name="quantity">Sold quantity or purchased quantity</param>
        /// <param name="total">Total quantity</param>
        /// <param name="returnedQuantity">Returned quantity</param>
        /// <param name="totalReturned">Total returned quantity</param>
        /// <param name="isFromSO"></param>
        public void UpdateProductStore(string productResource, int storeCode, decimal quantity, decimal total, decimal returnedQuantity, decimal totalReturned, bool isFromSO = false)
        {
            // Get product
            base_Product product = Get(productResource);

            // Get product store
            base_ProductStore productStore = product.base_ProductStore.SingleOrDefault(x => x.StoreCode.Equals(storeCode));

            // Create new product store
            if (productStore == null)
            {
                productStore = NewProductStore(product, storeCode);
            }

            if (isFromSO) // Call from SO
            {
                // Update returned quantity
                productStore.SOReturnedQuantity += returnedQuantity;

                // Update total returned
                productStore.SOTotalReturned += totalReturned;

                // Update sold quantity (include returned quantity)
                productStore.SoldQuantity += quantity - returnedQuantity;

                // Update total sale (include total returned)
                productStore.TotalSale += total - totalReturned;

                // Update total cost of goods
                productStore.TotalCOGS += product.AverageUnitCost * (quantity - returnedQuantity);
            }
            else // Call from PO
            {
                // Update returned quantity
                productStore.POReturnedQuantity += returnedQuantity;

                // Update total returned
                productStore.POTotalReturned += totalReturned;

                // Update purchase quantity (include returned quantity)
                productStore.PurchasedQuantity += quantity - returnedQuantity;

                // Update purchase subtotal (include returned quantity)
                productStore.PurchasedSubTotal += total - totalReturned;
            }

            // Update sale profit
            productStore.SaleProfit = productStore.TotalSale - productStore.TotalCOGS;

            // Update total profit
            productStore.TotalProfit = productStore.TotalSale - productStore.PurchasedSubTotal;
        }

        /// <summary>
        /// Get Product By resource string
        /// </summary>
        /// <param name="resourceString"></param>
        /// <returns></returns>
        public base_Product GetProductByResource(string resourceString)
        {
            Guid resourceGuid = Guid.NewGuid();
            if (Guid.TryParse(resourceString, out resourceGuid))
            {
                return Get(x=>x.Resource==resourceGuid);
            }
            return null;
        }
        #endregion

        #endregion
    }
}
