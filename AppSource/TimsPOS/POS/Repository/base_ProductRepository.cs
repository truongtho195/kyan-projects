//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Data.Objects;
using System.Linq;
using System.Linq.Expressions;
using CPC.POS.Database;

namespace CPC.POS.Repository
{
    /// <summary>
    /// Repository for table base_Product 
    /// </summary>
    public partial class base_ProductRepository
    {
        #region Auto Generate Code

        #region Constructors

        // Default constructor
        public base_ProductRepository()
        {
        }

        #endregion

        #region Basic C.R.U.D. Operations

        /// <summary>
        /// Add new base_Product.
        /// </summary>
        /// <param name="base_Product">base_Product to add.</param>
        /// <returns>base_Product have been added.</returns>
        public base_Product Add(base_Product base_Product)
        {
            UnitOfWork.Add<base_Product>(base_Product);
            return base_Product;
        }

        /// <summary>
        /// Adds a sequence of new base_Product.
        /// </summary>
        /// <param name="base_Product">Sequence of new base_Product to add.</param>
        /// <returns>Sequence of new base_Product have been added.</returns>
        public IEnumerable<base_Product> Add(IEnumerable<base_Product> base_Product)
        {
            UnitOfWork.Add<base_Product>(base_Product);
            return base_Product;
        }

        /// <summary>
        /// Delete a existed base_Product.
        /// </summary>
        /// <param name="base_Product">base_Product to delete.</param>
        public void Delete(base_Product base_Product)
        {
            Refresh(base_Product);
            if (base_Product.EntityState != System.Data.EntityState.Detached)
                UnitOfWork.Delete<base_Product>(base_Product);
        }

        /// <summary>
        /// Delete a sequence of existed base_Product.
        /// </summary>
        /// <param name="base_Product">Sequence of existed base_Product to delete.</param>
        public void Delete(IEnumerable<base_Product> base_Product)
        {
            int total = base_Product.Count();
            for (int i = total - 1; i >= 0; i--)
                Delete(base_Product.ElementAt(i));
        }

        /// <summary>
        /// Returns the first base_Product of a sequence that satisfies a specified condition or 
        /// a default value if no such base_Product is found.
        /// </summary>
        /// <param name="expression">A function to test each base_Product for a condition.</param>
        /// <returns>    
        /// Null if source is empty or if no base_Product passes the test specified by expression; 
        /// otherwise, the first base_Product in source that passes the test specified by expression.
        /// </returns>
        public base_Product Get(Expression<Func<base_Product, bool>> expression)
        {
            return UnitOfWork.Get<base_Product>(expression);
        }

        /// <summary>
        /// Get all base_Product.
        /// </summary>
        /// <returns>The new IList&lt;base_Product&gt; instance.</returns>
        public IList<base_Product> GetAll()
        {
            return UnitOfWork.GetAll<base_Product>().ToList();
        }

        /// <summary>
        /// Get all base_Product that satisfies a specified condition.
        /// </summary>
        /// <param name="expression">A function to test each base_Product for a condition.</param>
        /// <returns>The new IList&lt;base_Product&gt; instance.</returns>
        public IList<base_Product> GetAll(Expression<Func<base_Product, bool>> expression)
        {
            return UnitOfWork.GetAll<base_Product>(expression).ToList();
        }

        /// <summary>
        /// Get all base_Product.
        /// </summary>
        /// <returns>The new IEnumerable&lt;base_Product&gt; instance.</returns>
        public IEnumerable<base_Product> GetIEnumerable()
        {
            return UnitOfWork.GetIEnumerable<base_Product>();
        }

        /// <summary>
        /// Get all base_Product that satisfies a specified condition.
        /// </summary>
        /// <param name="expression">A function to test each base_Product for a condition.</param>
        /// <returns>The new IEnumerable&lt;base_Product&gt; instance.</returns>
        public IEnumerable<base_Product> GetIEnumerable(Expression<Func<base_Product, bool>> expression)
        {
            return UnitOfWork.GetIEnumerable<base_Product>(expression);
        }

        /// <summary>
        /// Get all base_Product.
        /// </summary>
        /// <returns>The new IQueryable&lt;base_Product&gt; instance.</returns>
        public IQueryable<base_Product> GetIQueryable()
        {
            return UnitOfWork.GetIQueryable<base_Product>();
        }

        /// <summary>
        /// Get all base_Product that satisfies a specified condition.
        /// </summary>
        /// <param name="expression">A function to test each base_Product for a condition.</param>
        /// <returns>The new IQueryable&lt;base_Product&gt; instance.</returns>
        public IQueryable<base_Product> GetIQueryable(Expression<Func<base_Product, bool>> expression)
        {
            return UnitOfWork.GetIQueryable<base_Product>(expression);
        }

        /// <summary>
        /// Take a few base_Product in a sequence was sorted on server.
        /// </summary>
        /// <param name="ignoreCount">Number of base_Product will ignore.</param>
        /// <param name="takeCount">Number of base_Product will take.</param>
        /// <param name="keys">The key columns by which to order the results.</param>
        /// <returns>The new IList&lt;base_Product&gt; instance.</returns>
        public IList<base_Product> GetRange(int ignoreCount, int takeCount, string keys)
        {
            return UnitOfWork.GetRange<base_Product>(ignoreCount, takeCount, keys);
        }

        /// <summary>
        /// Take a few base_Product in a sequence was sorted on server.
        /// </summary>
        /// <param name="ignoreCount">Number of base_Product will ignore.</param>
        /// <param name="takeCount">Number of base_Product will take.</param>
        /// <param name="keys">The key columns by which to order the results.</param>
        /// <param name="expression">A function to test each base_Product for a condition.</param>
        /// <returns>The new IList&lt;base_Product&gt; instance.</returns>
        public IList<base_Product> GetRange(int ignoreCount, int takeCount, string keys, Expression<Func<base_Product, bool>> expression)
        {
            return UnitOfWork.GetRange<base_Product>(ignoreCount, takeCount, keys, expression);
        }

        /// <summary>
        /// Updates an base_Product in the object context with data from the data source.
        /// </summary>
        /// <param name="base_Product">The base_Product to be refreshed.</param>
        public base_Product Refresh(base_Product base_Product)
        {
            UnitOfWork.Refresh<base_Product>(base_Product);
            if (base_Product.EntityState != System.Data.EntityState.Detached)
                return base_Product;
            return null;
        }

        /// <summary>
        /// Updates a sequence of base_Product in the object context with data from the data source.
        /// </summary>
        /// <typeparam name="base_Product">Type of object in a sequence to refresh.</typeparam>
        /// <param name="base_Product">Object collection to be refreshed.</param>
        public void Refresh(IEnumerable<base_Product> base_Product)
        {
            UnitOfWork.Refresh<base_Product>(base_Product);
        }

        /// <summary>
        /// Updates a sequence of base_Product in the object context with data from the data source.
        /// </summary>
        public void Refresh()
        {
            UnitOfWork.Refresh<base_Product>();
        }

        /// <summary>
        /// Persists all updates to the data source and resets change tracking in the object context.
        /// </summary>
        public void Commit()
        {
            UnitOfWork.Commit();
        }

        /// <summary>
        /// Persists all updates to the data source with the specified System.Data.Objects.SaveOptions.
        /// </summary>
        /// <param name="options">A System.Data.Objects.SaveOptions value that determines the behavior of the operation.</param>
        public void Commit(SaveOptions options)
        {
            UnitOfWork.Commit(options);
        }

        /// <summary>
        /// Starts a database transaction.
        /// </summary>
        public void BeginTransaction()
        {
            UnitOfWork.BeginTransaction();
        }

        /// <summary>
        /// Commits the database transaction.
        /// </summary>
        public void CommitTransaction()
        {
            UnitOfWork.CommitTransaction();
        }

        /// <summary>
        /// Rolls back a transaction from a pending state.
        /// </summary>
        public void RollbackTransaction()
        {
            UnitOfWork.RollbackTransaction();
        }

        #endregion

        #endregion

        #region Custom Code

        #region Private Methods

        /// <summary>
        /// Get product by resource
        /// </summary>
        /// <param name="resource"></param>
        /// <returns></returns>
        private base_Product Get(string resource)
        {
            // Convert product resource to Guid
            Guid productGuid = new Guid();
            Guid.TryParse(resource, out productGuid);

            // Get product to update quantity
            return this.Get(x => x.Resource.Equals(productGuid));
        }

        /// <summary>
        /// Update new quantity to OnHandStore
        /// </summary>
        /// <param name="product"></param>
        /// <param name="storeNumber"></param>
        /// <param name="quantity"></param>
        /// <param name="isDecreased"></param>
        /// <returns></returns>
        private int UpdateOnHandStore(base_Product product, int storeNumber, int quantity, bool isDecreased = false)
        {
            int onHandStore = 0;

            if (product != null)
            {
                int newQuantity = quantity;
                if (isDecreased)
                    newQuantity *= -1;

                switch (storeNumber)
                {
                    case 0:
                        product.OnHandStore1 += newQuantity;
                        onHandStore = product.OnHandStore1;
                        break;
                    case 1:
                        product.OnHandStore2 += newQuantity;
                        onHandStore = product.OnHandStore2;
                        break;
                    case 2:
                        product.OnHandStore3 += newQuantity;
                        onHandStore = product.OnHandStore3;
                        break;
                    case 3:
                        product.OnHandStore4 += newQuantity;
                        onHandStore = product.OnHandStore4;
                        break;
                    case 4:
                        product.OnHandStore5 += newQuantity;
                        onHandStore = product.OnHandStore5;
                        break;
                    case 5:
                        product.OnHandStore6 += newQuantity;
                        onHandStore = product.OnHandStore6;
                        break;
                    case 6:
                        product.OnHandStore7 += newQuantity;
                        onHandStore = product.OnHandStore7;
                        break;
                    case 7:
                        product.OnHandStore8 += newQuantity;
                        onHandStore = product.OnHandStore8;
                        break;
                    case 8:
                        product.OnHandStore9 += newQuantity;
                        onHandStore = product.OnHandStore9;
                        break;
                    case 9:
                        product.OnHandStore10 += newQuantity;
                        onHandStore = product.OnHandStore10;
                        break;
                    default:
                        break;
                }

                // Update total quantity
                product.QuantityOnHand += newQuantity;
            }

            // Get product store by store number
            base_ProductStore productStore = product.base_ProductStore.SingleOrDefault(x => x.StoreCode.Equals(storeNumber));

            // Update product store quantity
            if (productStore != null)
            {
                productStore.QuantityOnHand = onHandStore;
                productStore.QuantityAvailable = productStore.QuantityOnHand - productStore.QuantityOnOrder;

                // Update quantity on hand for product UOM
                if (productStore.base_ProductUOM != null)
                    foreach (base_ProductUOM productUOMItem in productStore.base_ProductUOM)
                    {
                        if (productUOMItem.BaseUnitNumber != 0)
                            productUOMItem.QuantityOnHand = productStore.QuantityOnHand / productUOMItem.BaseUnitNumber;
                    }
            }
            else
            {
                productStore = new base_ProductStore();
                productStore.ProductId = product.Id;
                productStore.StoreCode = storeNumber;
                productStore.QuantityOnHand = onHandStore;
                productStore.QuantityAvailable = onHandStore;
                product.base_ProductStore.Add(productStore);
            }

            return onHandStore;
        }

        /// <summary>
        /// Save adjustment when cost or quantity changed
        /// </summary>
        /// <param name="productModel"></param>
        /// <param name="productStoreModel"></param>
        private void SaveAdjustment(base_Product product, int deltaQuantity, int storeCode, DateTime loggedTime)
        {
            // Get product store by store code
            base_ProductStore productStore = product.base_ProductStore.SingleOrDefault(x => x.StoreCode.Equals(storeCode));

            // Create new product store
            if (productStore == null)
                productStore = new base_ProductStore { StoreCode = storeCode };

            // Add new product store to database
            product.base_ProductStore.Add(productStore);

            // Get new and old quantity
            int newQuantity = productStore.QuantityOnHand + deltaQuantity;
            int oldQuantity = productStore.QuantityOnHand;

            // Get new and old cost
            decimal newCost = product.AverageUnitCost;
            decimal oldCost = product.AverageUnitCost;

            // Save quantity adjustment
            // Create new quantity adjustment item
            base_QuantityAdjustment quantityAdjustment = new base_QuantityAdjustment();
            quantityAdjustment.ProductId = product.Id;
            quantityAdjustment.ProductResource = product.Resource.ToString();
            quantityAdjustment.NewQty = newQuantity;
            quantityAdjustment.OldQty = oldQuantity;
            quantityAdjustment.AdjustmentQtyDiff = newQuantity - oldQuantity;
            quantityAdjustment.CostDifference = newCost * quantityAdjustment.AdjustmentQtyDiff;
            quantityAdjustment.LoggedTime = loggedTime;
            quantityAdjustment.Reason = (short)AdjustmentReason.TransferedStock;
            quantityAdjustment.Status = (short)AdjustmentStatus.Normal;
            quantityAdjustment.UserCreated = Define.USER.LoginName;
            quantityAdjustment.IsReversed = false;
            quantityAdjustment.StoreCode = storeCode;

            // Add new quantity adjustment item to database
            UnitOfWork.Add(quantityAdjustment);

            // Save cost adjustment
            // Create new cost adjustment item
            base_CostAdjustment costAdjustment = new base_CostAdjustment();
            costAdjustment.ProductId = product.Id;
            costAdjustment.ProductResource = product.Resource.ToString();
            costAdjustment.AdjustmentNewCost = newCost;
            costAdjustment.AdjustmentOldCost = oldCost;
            costAdjustment.AdjustCostDifference = newCost - oldCost;
            costAdjustment.NewCost = newCost * newQuantity;
            costAdjustment.OldCost = oldCost * newQuantity;
            costAdjustment.CostDifference = costAdjustment.NewCost - costAdjustment.OldCost;
            costAdjustment.LoggedTime = loggedTime;
            costAdjustment.Reason = (short)AdjustmentReason.TransferedStock;
            costAdjustment.Status = (short)AdjustmentStatus.Normal;
            costAdjustment.UserCreated = Define.USER.LoginName;
            costAdjustment.IsReversed = false;
            costAdjustment.StoreCode = storeCode;

            // Add new cost adjustment item to database
            UnitOfWork.Add(costAdjustment);
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Update on hand quantity
        /// </summary>
        /// <param name="productResource">Resource of product that update quantity</param>
        /// <param name="storeNumber">Store number</param>
        /// <param name="quantity">Quantity</param>
        /// <param name="isDecreased">Quantity increase or decrease. Default is increase</param>
        /// <returns>The new on hand quantity</returns>
        public int UpdateOnHandQuantity(string productResource, int storeNumber, int quantity, bool isDecreased = false, int baseUnitNumber = 1)
        {
            int onHandStore = 0;

            // Get product
            base_Product product = Get(productResource);

            onHandStore = UpdateOnHandStore(product, storeNumber, quantity * baseUnitNumber, isDecreased);

            // Accept changes
            this.Commit();

            return onHandStore;
        }

        /// <summary>
        /// Transfer product from source to target store
        /// </summary>
        /// <param name="productResources">Product resource list</param>
        /// <param name="sourceStoreNumber">Source store number</param>
        /// <param name="targetStoreNumber">Target store number</param>
        /// <param name="quantity">Quantity</param>
        /// <param name="isReversed">Default is false</param>
        public void TransferStock(string productResource, int sourceStoreNumber, int targetStoreNumber,
            int quantity, bool isReversed = false, int baseUnitNumber = 1)
        {
            // Get logged time
            DateTime loggedTime = DateTimeExt.Now;

            // Get delta quantity
            int deltaQuantity = quantity * baseUnitNumber;

            // Get product
            base_Product product = Get(productResource);

            // Save adjustment when change quantity in source store
            SaveAdjustment(product, -1 * deltaQuantity, sourceStoreNumber, loggedTime);

            // Save adjustment when change quantity in target store
            SaveAdjustment(product, deltaQuantity, targetStoreNumber, loggedTime);

            // Decrease quantity at source store
            UpdateOnHandStore(product, sourceStoreNumber, deltaQuantity, !isReversed);

            // Increase quantity at target store
            UpdateOnHandStore(product, targetStoreNumber, deltaQuantity, isReversed);

            // Accept changes
            this.Commit();
        }

        /// <summary>
        /// Update quantity on order (PO)
        /// </summary>
        public void UpdateQuantityOnOrder(string productResource, int storeCode, int quantity)
        {
            // Get product
            base_Product product = Get(productResource);

            if (product != null)
            {
                // Update quantity on order in product
                product.QuantityOnOrder += quantity;

                // Get product store
                base_ProductStore productStore = product.base_ProductStore.SingleOrDefault(x => x.StoreCode.Equals(storeCode));

                if (productStore != null)
                {
                    // Update quantity on order in product store
                    productStore.QuantityOnOrder += quantity;
                }
            }
        }

        /// <summary>
        /// Update quantity on customer (SO)
        /// </summary>
        public void UpdateQuantityOnCustomer(string productResource, int storeCode, int quantity)
        {
            // Get product
            base_Product product = Get(productResource);

            if (product != null)
            {
                // Update quantity on order in product
                product.QuantityOnCustomer += quantity;

                // Get product store
                base_ProductStore productStore = product.base_ProductStore.SingleOrDefault(x => x.StoreCode.Equals(storeCode));

                if (productStore != null)
                {
                    // Update quantity on order in product store
                    productStore.QuantityOnCustomer += quantity;

                    // Update quantity available in product store
                    productStore.QuantityAvailable -= quantity;
                }
            }
        }

        #endregion

        #endregion
    }
}
